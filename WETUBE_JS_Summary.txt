###### WETUBE JS SUMMARY ######

< Settings >

1. #### Node JS ####
== 브라우저 바깥에서 쓸 수 있는 자바스크립트

2. #### NPM ####
== 자바스크립트 언어를 위한 패키지 매니저
== Node JS와 상호작용을 할 수 있게 해줌
== 

3. #### Express - NPM ####
== npm i(=install) express -> node_modules파일 + package-lock.json 파일 생성
                           -> 기존 package.json파일 dependencies express 생성됨
                           -> npm i 실행 시 dependencies에 해당되는 모듈들을 다 설치해줌
                           -> .gitignore -> /node_modules -> 다른사람들에게 node_modules 파일을 보내지 않아도 됨. package.json파일만 있어도 됨
                           -> dependencies에 express 있을 시 이후 npm i 만 실행해도 됨
                           -> package-lock.json -> 패키지들을 안전하게 관리함

== npm init -> 새 npm패키지 또는 기존 npm 패키지를 설정 할 수 있음 
            -> package.json 만드는 걸 도와줌
== node_modules -> npm으로 설치한 모든 패키지가 저장됨

4. #### Package.json ####
== json -> 그냥 텍스트 파일임. 파일에 정보를 저장하기 위해 만든 방식 중 하나
== npm 활용 -> npm init을 통해 package.json 생성
== node.js 관련 정보를 담는 방법으로 일반적인 Text이므로 무엇을 넣어도 상관없음

== script 엔트리를 생성하고 그 안에 script를 입력하면 --> npm run (script이름) 을 사용할 수 있음
(ex)ppopopp
"scripts": {
    "win": "node index.js" --> npm run win 실행 시 index.js파일 실행됨
}

"scripts": {
    "dev" : "nodemon -- exec babel-node src/server.js" --> npm run dev 사용 가능
}

5. #### Babeljs.io - JS compiler ####
== https://babeljs.io/setup#installation 참조
== 작성한 최신 자바스크립트를 nodeJS가 이해할 수 있는 자바스크립트로 바꿔주는 것
== dependencies: 프로젝트가 작동하기 위해 필요한 것들
== devDependencies: 개발자가 개발할 때 필요한 것들 
(ex) -- nodemon, babel-node
1. nodemon(파일을 보고 있다가 변화가 있으면 commend를 재시작 시켜줌) 서버를 만드는 데 필수적인 요소는 아니지만 개발환경을 편하게 해줌
2. nodemon -> babel-node를 실행 -> src 폴더에 가서 server.js 실행


NodeJS에서 필요한 babel설치
npm install --save-dev @babel/core
npm install @babel/preset-env --save-dev

babel.config.json파일 생성
```
{
"presets": ["@babel/preset-env"]
}
```

@babel/preset-env
@babel/preset-env는 환경에 필요한 구문 변환을 세부적으로 관리할 필요 없이 최신 JavaScript를 사용할 수 있게 해주는 preset

6. #### Nodemon ####
== https://babeljs.io/setup#installation 참조
== 실행방법
    1. npm install @babel/core @babel/node --save-dev
    2. npm i nodemon --save-dev

== node index.js(nodeJS로 실행) -> babel-node index.js(최신 문법 코드로 실행) -> nodemon --exec babel-node index.js(babel-node를 실행하는 nodemon)
== ex) "scripts": { nodemon --exec babel-node index.js" }
== 만든 파일이 수정되는 걸 감시해주는 패키지 -> 파일이 수정되면 알아서 재시작해줌 
                                          -> npm run 을 계속 실행해주지 않아도 됨

-----------------------------------------------------------------------------------------------------------------------------------------------

< Server >

1. #### Server ####
== 항상 켜져있고 인터넷에 연결 돼 있으면서 request를 listening하고 있는 컴퓨터 
== 브라우저는 서버에게 홈페이지를 요구하고, 브라우저가 요청한 걸 서버는 응답해줘야 함 --> 응답이 없을 시 무한 로딩
(ex)
import express from "express" == const 
const app = express();
app.get("/", handleHome) -> get(route, handler) ----> 서버에게 홈페이지를 request 후 handler 응답

2. #### GET Requests ####
== 브라우저는 대신해서  웹사이트를 요청하고, 페이지를 가져다 줌 == 페이지를 가져와 !!
== (ex) import express from "express";
        const app = express();

        => app.get("root", callback)
        app.get("/", () => console.log("Somebody is trying to go home.")) => 누군가가 root page로 get request를 보낸다면 함수를 실행

        const handleHome = () => console.log("Somebody is trying to go home.") => 위와 동일
        app.get("/", handleHome))

        app.get("/", console.log("Somebody is trying to go home.")) => 무조건 함수로 실행해야 하므로 오류
== request => 사용자가 원하는 것을 요청하는 것 
           => but, 사용자가 직접 get request를 하는 것이 아니라 브라우저가 get request를 보내는 것
           => get request에는 어디로 가려는지 /home, /login과 같은 route가 있음.

3. #### ( Request, Responses ) ####
== request를 받으면 브라우저가 request를 보내고 root 페이지를 가져달라는 request를 받으면 응답 !!
==  express.js에서 method 확인
    (ex) const handleHome = (req, res) => {
            return res.end(); -> 접속 종료
            return res.send("Hello"); -> 메세지 보냄
        };
 
4. #### Middleware ####
== 말 그대로 중간에 있는 software - request와 response의 중간 
== 모든 함수는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 가지고 있음 (req,res,next) / 하지만 그 중 함수가 next()를 호출 시 Middleware이 됨
== next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있음 
== 원하는 만큼 사용가능하며 누군가가 응답하기 전까지 request와 관련된 모든 controller는 모두 Middleware이다
== app.use => 모든 router들에서 사용 => app.get 전에 사용되어야 함

5. #### Morgan ####
== npm i morgan
== NodeJS를 위한 HTTP request logger
== npm i morgan
https://www.npmjs.com/package/morgan

== Morgan사용법
https://www.npmjs.com/package/morgan#examples

skip을 사용해서 특정 statusCode만 필터 가능
```
// EXAMPLE: only log error responses
morgan('combined', {
skip: function (req, res) { return res.statusCode < 400 }
})
```

6. #### Router && Controllers ####

모든 Express 애플리케이션에는 앱 라우터가 내장되어 있음.
라우터는 미들웨어 자체처럼 작동하므로 app.use()에 대한 인수로 또는 다른 라우터의 use() 메서드에 대한 인수로 사용 가능
최상위 익스프레스 객체에는 새로운 라우터 객체를 생성하는 Router() 메서드가 있다.

https://expressjs.com/ko/4x/api.html#router

(ex)
const videoRouter = express.Router();
const handleWatchVideo = (req,res) => res.send("Watch Video");
videoRouter.get("/watch",handleWatchVideo);

app.use("/videos", videoRouter); 
-> 누군가가 "/videos"로 시작하는 url에 접근하면
-> express는 videoRouter로 들어가고
-> videoRouter는 가지고 있는 url로 들어감으로써 handleWatchVideo 실행

-> Router와 Controller를 같이 쓰는 건 권장하지 않음
-> 따로 작성한 뒤 export && import 실행
-> export default는 내보내는 게 1개 밖에 없기에 변수명을 바꿔줘도 되지만
    export는 내보내는 게 여러가지라 선언된 변수명 그대로 써줘야 함

7. #### Export && Import ####
== 프로젝트에 있는 모든 파일은 분리된 모습이므로
== 무언가를 바깥에 공유하기 위해서는 export를 먼저 해줘야 함

====> Default Export 
== default export일 경우 이름을 동일하게 설정하지 않아도 됨 하지만 파일 당 하나만 설정할 수 있음
(ex)```
export default globalRouter;

=> 둘 다 가능
import globalRouter from "./routers/globalRouter";
import global from "./routers/globalRouter";
```

====> Export
== 하나의 파일에 export 여러개일 경우에는 const 앞에 export 사용 하지만 이름을 동일하게 설정해야 함
     export const trending = (req, res) => res.send("Home Page Videos");
     export const watch = (req, res) => res.send("Watch");
     export const edit = (req, res) => res.send("Edit");

     import { trending } from "../controllers/videoController";


12. #### URL Parameters ####
(ex)
videoRouter.get("/:변수몀/edit", edit);
-> URL 안에 변수를 넣어줌
-> req.params.변수명

13. #### Rendering ####
-> pug를 렌더링해주는건 controller!
-> render는 2개의 argument를 받는다
-> 하나는 view, 다른 하나는 템플릿에 보낼 변수!
-> 템플릿에 변수를 생성하는법 #{}




